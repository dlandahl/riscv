
reduce :: combinational (mask: constant | value: wire[8]) -> result: wire {
    result = ~(^(value & mask));
}

Lfsr_Updown :: chip (clk: wire, reset: wire, enable: wire, up_down: wire) -> (count: flipflop[8], overflow: wire) {

    combinational
        if in.up_down  out.overflow = out.count == 'b0000_0001;
        else           out.overflow = out.count == 'b1000_0000;

    sequential (clk) if in.reset {
        out.count <= 8'b0;
    } else if in.enable {
        if in.up_down {
            out.count <= { reduce('b0110_0011, out.count), out.count[7:1] };
        } else {
            out.count <= { out.count[6:0], reduce('b1011_0001, out.count) };
        }
    }
}

testbench {
    step_simulation :: (num: int) #expand {
        for 1..num {
            step_simulation();
            lfsr.clk = !lfsr.clk;

            log("State: %", lfsr);
        }
    }

    using lfsr := instantiate(Lfsr_Updown);

    in.clk = 0;
    in.reset = 1;
    in.enable = 0;
    in.up_down = 0;

    step_simulation(10);
    in.reset = 0;
    step_simulation(1);
    in.enable = 1;
    step_simulation(20);
    in.up_down = 1;
    step_simulation(30);

    testbench_assert(out.count == 0x1233);
}
