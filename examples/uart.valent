
Uart_Tx_Ctrl :: module (
    clock: wire,
    send: wire,
    data: wire[8]
  ) -> (
    ready: wire,
    uart_tx: flipflop
  ) {

    Uart_Frame :: register {
        stop_bit;
        data[8];
        start_bit;
    }

    tx_data: flipflop[Uart_Frame];

    // When `send` goes high, latch signal to be sent into the `tx_data` register
    sequential (clock) {
        if send tx_data <- { 1'b1, data, 1'b0 };
    }


    Tx_State :: enum[2] {
       RDY;
       LOAD_BIT;
       SEND_BIT;
    }

    tx_state: flipflop[Tx_State];

    // Keep track of the current send state (wait for baud, send, standby)
    // and update the output transfer value
    sequential (clock) {
        switch tx_state {
            case Tx_State.RDY {
                uart_tx <- 1;
                if send tx_state <- Tx_State.LOAD_BIT;
            }

            case Tx_State.LOAD_BIT {
                uart_tx <- (tx_data >> bit_index)[0];
                tx_state <- Tx_State.SEND_BIT;
            }

            case Tx_State.SEND_BIT {
                if baud_done {
                    if bit_index == BIT_INDEX_MAX
                        tx_state <- Tx_State.RDY;
                    else
                        tx_state <- Tx_State.LOAD_BIT;
                }
            }
        }
    }

    combinational ready = tx_state == Tx_State.RDY;


    // Track which bit of tx_data should currently be sent
    BIT_INDEX_MAX :: 10;
    bit_index: flipflop[4];

    sequential (clock) {
        switch tx_state {
            case Tx_State.RDY      bit_index <- 0;
            case Tx_State.LOAD_BIT bit_index <-,trunc bit_index + 1;
        }
    }


    // Counter to wait for the baud period
    BAUD_TIMER_MAX :: 14'10416;

    baud_timer: flipflop[14];
    baud_done: wire;
    combinational baud_done = baud_timer == BAUD_TIMER_MAX;

    sequential (clock) {
        if tx_state == Tx_State.RDY || baud_done {
            baud_timer <- 0;
        } else {
            baud_timer <-,trunc baud_timer + 1;
        }
    }
}
