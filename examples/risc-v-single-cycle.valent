
Processor :: module (
    clock: wire,
    reset: wire,
    instruction: wire[RiscV_Instruction],
    data_in: wire[32]
) -> (
    pc: flipflop[32],
    bus: wire[Memory_Interface],
) {

    Mode :: enum [1] { EXECUTE; MEMORY; }
    mode: flipflop[Mode];

    // Alternate cycles for instruction execution and waiting for memory latency

    sequential (clock) {
        if reset mode <= Mode.EXECUTE;
        else     mode <= !mode;
    }

    RiscV_Instruction :: register[32] {
        opcode    [Opcode];
        dest_reg  [5];
        funct3    [Funct];
        src_reg1  [5];
        src_reg2  [5];
        funct7    [7];
    }

    opcode: wire[Opcode];
    combinational opcode = instruction.opcode;



    imm: wire[32];

    I_immediate: wire[32];
    S_immediate: wire[32];
    B_immediate: wire[32];
    U_immediate: wire[32];
    J_immediate: wire[32];

    op: wire[32];
    combinational {
        op = instruction;

        I_immediate = { 21 # op[31], op[30:20] };
        S_immediate = { 21 # op[31], op[30:25], op[11:7] };
        B_immediate = { 20 # op[31], op[7], op[30:25], op[11:8], 1'b0 };
        U_immediate = { op[31:12], 12'b0 };
        J_immediate = { 12 # op[31], op[19:12], op[20], op[30:25], op[24:21], 1'b0 };

        switch instruction.opcode {
            case Opcode.AUIPC  imm = U_immediate;
            case Opcode.LUI    imm = U_immediate;
            case Opcode.LOAD   imm = I_immediate;
            case Opcode.STORE  imm = S_immediate;
            case Opcode.OP_IMM imm = I_immediate;
            case Opcode.OP     imm = 32'b0;
            case Opcode.BRANCH imm = B_immediate;
            case Opcode.JAL    imm = J_immediate;
            case Opcode.JALR   imm = J_immediate;
        }
    }



    pc_next: wire[32 + 1];

    sequential (clock) {
        if mode == Mode.EXECUTE {
            pc <=,trunc pc_next;
        }

        if reset pc <= 0;
    }

    branch_taken: wire;

    combinational {
        branch_taken = alu_result == 1;

        if opcode == Opcode.JAL {
            pc_next = pc + imm;
        } else if opcode == Opcode.JALR {
            pc_next = pc + alu_result;
        } else if opcode == Opcode.BRANCH && branch_taken {
            pc_next = pc + imm;
        } else {
            pc_next = pc + 4;
        }
    }



    register_file: [32] memory[32];

    sequential (clock) {
        if !reset && mode == Mode.EXECUTE {
            switch (opcode) {
                case Opcode.OP      register_file[rd] <= alu_result;
                case Opcode.OP_IMM  register_file[rd] <= alu_result;
                case Opcode.LUI     register_file[rd] <= imm;
                case Opcode.AUIPC   register_file[rd] <=,trunc imm + pc;
            }
        }
    }

    rs1: wire[32];
    rs2: wire[32];
    rd:  wire[5];

    combinational {
        rd  = instruction.dest_reg;
        rs1 = register_file[instruction.src_reg1];
        rs2 = register_file[instruction.src_reg2];
    }



    byte_offset: wire[4];
    offset:      wire[8];

    combinational {
        bus.write_enable = 4'b0;

        byte_offset[1:0] = alu_result[1:0];
        offset           = byte_offset * 8;

        if mode == Mode.EXECUTE && opcode == Opcode.STORE {
            switch instruction.funct3 {
                case Funct.STORE_SB bus.write_enable = 4'b0001 << byte_offset;
                case Funct.STORE_SH bus.write_enable = 4'b0011 << byte_offset;
                case Funct.STORE_SW bus.write_enable = 4'b1111;
            }
        }

        bus.address = { alu_result[31:2], 2'b0 };
        bus.data = rs2 << offset;
    }

    sequential (clock) if mode == Mode.MEMORY {
        if opcode == Opcode.LOAD switch instruction.funct3 {
            case Funct.LOAD_LB  register_file[rd][7:0] <= data_in[offset +: 8];
            case Funct.LOAD_LH  register_file[rd] <= { 16 # data_in[16 + offset +: 1], data_in[offset +: 16] };
            case Funct.LOAD_LW  register_file[rd] <= data_in;
            case Funct.LOAD_LBU register_file[rd] <= { 24'b0, data_in[offset +: 8] };
            case Funct.LOAD_LHU register_file[rd] <= { 16'b0, data_in[offset +: 16] };
        }
    }



    alu_result: wire[32];
    alu_lhs: wire[32];
    alu_rhs: wire[32];

    use_immediate: wire;
    funct7: wire;

    combinational {
        alu_lhs = rs1;

        use_immediate = opcode == Opcode.OP_IMM
                     || opcode == Opcode.LOAD
                     || opcode == Opcode.STORE
                     || opcode == Opcode.JALR;

        if use_immediate {
            alu_rhs = imm;
        } else {
            alu_rhs = rs2;
        }

        alu_result =,trunc alu_lhs + alu_rhs;

        funct7 = instruction.funct7 > 0;

        if opcode == Opcode.OP || opcode == Opcode.OP_IMM {
            switch instruction.funct3 {
                case Funct.OP_ADD_SUB
                    if funct7      alu_result       = alu_lhs  -  alu_rhs;
                    else           alu_result =,trunc alu_lhs  +  alu_rhs;
                case Funct.OP_SRL_SRA
                    if funct7      alu_result       = alu_lhs >>  alu_rhs;
                    else           alu_result       = 32'b0;               // Todo: arithmetic shift
                case Funct.OP_SLL  alu_result       = alu_lhs  << alu_rhs;
                case Funct.OP_SLT  alu_result[0]    = alu_lhs  <  alu_rhs; // Todo: sign
                case Funct.OP_SLTU alu_result[0]    = alu_lhs  <  alu_rhs;
                case Funct.OP_XOR  alu_result       = alu_lhs  ^  alu_rhs;
                case Funct.OP_OR   alu_result       = alu_lhs  |  alu_rhs;
                case Funct.OP_AND  alu_result       = alu_lhs  &  alu_rhs;
            }
        }

        else if opcode == Opcode.BRANCH switch instruction.funct3 {
            case Funct.BRANCH_BEQ  alu_result = { 31'b0, alu_lhs == alu_rhs };
            case Funct.BRANCH_BNE  alu_result = { 31'b0, alu_lhs != alu_rhs };
            case Funct.BRANCH_BLT  alu_result = { 31'b0, alu_lhs <  alu_rhs }; // Todo: sign
            case Funct.BRANCH_BGE  alu_result = { 31'b0, alu_lhs >= alu_rhs }; // Todo: sign
            case Funct.BRANCH_BLTU alu_result = { 31'b0, alu_lhs <  alu_rhs };
            case Funct.BRANCH_BGEU alu_result = { 31'b0, alu_lhs >= alu_rhs };
        }
    }
}

Controller :: module (clock: wire, reset: wire) {

    processor: Processor(clock, reset);

    data_memory: Block_Ram(clock);

    combinational {
        data_memory.bus = processor.bus;
        processor.data_in = data_memory.output;
    }

    instruction_memory: Block_Ram(clock);

    combinational {
        instruction_memory.bus.address = processor.pc;
        instruction_memory.bus.write_enable = 4'b0;

        processor.instruction = instruction_memory.output;
    }
}

Memory_Interface :: register {
    address[32];
    data[32];
    write_enable[4];
}

Block_Ram :: module (clock: wire, bus: wire[Memory_Interface]) -> output: flipflop[32] {

    storage: ['h400] memory[32];

    native_address: wire[30];
    combinational native_address = (bus.address)[31:2];

    sequential (clock) {
        if (bus.write_enable)[0] storage[bus.address][7:0]   <= (bus.data)[7:0];
        if (bus.write_enable)[1] storage[bus.address][15:8]  <= (bus.data)[15:8];
        if (bus.write_enable)[2] storage[bus.address][23:16] <= (bus.data)[23:16];
        if (bus.write_enable)[3] storage[bus.address][31:24] <= (bus.data)[31:24];

        output <= storage[bus.address];
    }
}

Opcode :: enum[7] {
    AUIPC  :: 'b00_101_11;
    LUI    :: 'b01_101_11;
    LOAD   :: 'b00_000_11;
    STORE  :: 'b01_000_11;
    OP_IMM :: 'b00_100_11;
    OP     :: 'b01_100_11;
    BRANCH :: 'b11_000_11;
    JALR   :: 'b11_001_11;
    JAL    :: 'b11_011_11;
}

Funct :: enum[3] {
    OP_ADD_SUB  :: 'b000;
    OP_SLL      :: 'b001;
    OP_SLT      :: 'b010;
    OP_SLTU     :: 'b011;
    OP_XOR      :: 'b100;
    OP_SRL_SRA  :: 'b101;
    OP_OR       :: 'b110;
    OP_AND      :: 'b111;

    BRANCH_BEQ  :: 'b000;
    BRANCH_BNE  :: 'b001;
    BRANCH_BLT  :: 'b010;
    BRANCH_BGE  :: 'b011;
    BRANCH_BLTU :: 'b100;
    BRANCH_BGEU :: 'b101;

    LOAD_LB     :: 'b000;
    LOAD_LH     :: 'b001;
    LOAD_LW     :: 'b010;
    LOAD_LBU    :: 'b100;
    LOAD_LHU    :: 'b101;

    STORE_SB    :: 'b000;
    STORE_SH    :: 'b001;
    STORE_SW    :: 'b010;
}
