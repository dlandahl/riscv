
Processor :: module (
    clock: wire,
    reset: wire,
    instruction: wire[RiscV_Instruction],
    data_in: wire[32]
) -> (
    pc: flipflop[32],
    write: flipflop[Memory_Write],
    read: wire[Memory_Read]
) {

    RiscV_Instruction :: register[32] {
        opcode    [Opcode];
        dest_reg  [5];
        funct3    [Funct];
        src_reg1  [5];
        src_reg2  [5];
        funct7    [7];
    }

    opcode: wire[Opcode];
    combinational opcode = instruction.opcode;



    imm: wire[32];

    I_immediate: wire[32];
    S_immediate: wire[32];
    B_immediate: wire[32];
    U_immediate: wire[32];
    J_immediate: wire[32];

    op: wire[32];
    combinational {
        op = instruction;

        I_immediate = { 21 # op[31], op[30:20] };
        S_immediate = { 21 # op[31], op[30:25], op[11:7] };
        B_immediate = { 20 # op[31], op[7], op[30:25], op[11:8], 1'b0 };
        U_immediate = {      op[31:12], 12'b0 };
        J_immediate = { 12 # op[31], op[19:12], op[20], op[30:25], op[24:21], 1'b0 };

        switch instruction.opcode {
            case Opcode.AUIPC  imm = U_immediate;
            case Opcode.LUI    imm = U_immediate;
            case Opcode.LOAD   imm = I_immediate;
            case Opcode.STORE  imm = S_immediate;
            case Opcode.OP_IMM imm = I_immediate;
            case Opcode.OP     imm = 32'b0;
            case Opcode.BRANCH imm = B_immediate;
            case Opcode.JAL    imm = J_immediate;
            case Opcode.JALR   imm = J_immediate;
        }
    }



    pc_next: wire[32 + 1];

    sequential (clock) if !reset {
        pc <=,trunc pc_next;
    } else {
        pc <= 0;
    }

    branch_taken: wire;
    jump_target:  wire[32];

    combinational {
        branch_taken = alu_result == 1;

        if opcode == Opcode.JAL {
            pc_next = pc + imm;
        } else if opcode == Opcode.JALR {
            pc_next = pc + alu_result;
        } else if opcode == Opcode.BRANCH && branch_taken {
            pc_next = pc + imm;
        } else {
            pc_next = pc + 4;
        }
    }



    register_file: [32] memory[32];

    Memory_Write :: register {
        active;
        address[32];
        data[32];
    }

    sequential (clock) if !reset {
        if opcode == Opcode.OP || opcode == Opcode.OP_IMM {
            register_file[rd] <= alu_result;
        }

        if opcode == Opcode.LUI {
            register_file[rd] <= imm;
        }

        if opcode == Opcode.AUIPC {
            register_file[rd] <=,trunc imm + pc;
        }

        if opcode == Opcode.STORE {
            write <= { 1'b1, alu_result, rs1 };
        } else {
            write <= 0;
        }
    }

    rs1: wire[32];
    rs2: wire[32];
    rd:  wire[5];

    combinational {
        rd  = instruction.dest_reg;
        rs1 = register_file[instruction.src_reg1];
        rs2 = register_file[instruction.src_reg2];

        if last_cycle_was_load {
            // If a load started on the previous cycle, and the destination register is a source register in this cycle,
            // point rs* to data_in because the loaded data is not in the register file yet.

            if last_load_destination == instruction.src_reg1 {
                rs1 = data_in;
            }

            if last_load_destination == instruction.src_reg2 {
                rs2 = data_in;
            }
        }
    }



    Memory_Read :: register {
        active;
        address[32];
    }

    combinational {
        read.active = opcode == Opcode.LOAD;
        read.address = alu_result;
    }

    last_cycle_was_load: flipflop;
    last_load_destination: flipflop[5];

    sequential (clock) {
        if opcode == Opcode.LOAD {
            last_cycle_was_load <= 1'b1;
            last_load_destination <= rd;
        } else {
            last_cycle_was_load <= 1'b0;
        }

        if last_cycle_was_load {
            register_file[rd] <= data_in;
        }
    }



    alu_result: wire[32];
    alu_lhs: wire[32];
    alu_rhs: wire[32];

    use_immediate: wire;
    funct7: wire;

    combinational {
        alu_lhs = rs1;

        use_immediate = opcode == Opcode.OP_IMM
                     || opcode == Opcode.LOAD
                     || opcode == Opcode.STORE
                     || opcode == Opcode.JALR;

        if use_immediate {
            alu_rhs = imm;
        } else {
            alu_rhs = rs2;
        }

        funct7 = instruction.funct7 > 0;

        if opcode == Opcode.OP || opcode == Opcode.OP_IMM {
            switch instruction.funct3 {
                case Funct.OP_ADD_SUB
                    if funct7      alu_result = alu_lhs  -  alu_rhs;
                    else           alu_result =,trunc alu_lhs  +  alu_rhs;
                case Funct.OP_SRL_SRA
                    if funct7      alu_result = alu_lhs >>  alu_rhs;
                    else           alu_result = 32'b0; // alu_lhs >>> alu_rhs;
                case Funct.OP_SLL  alu_result = alu_lhs  << alu_rhs;
                case Funct.OP_SLT  alu_result[0] = alu_lhs  <  alu_rhs; // Todo: sign
                case Funct.OP_SLTU alu_result[0] = alu_lhs  <  alu_rhs;
                case Funct.OP_XOR  alu_result = alu_lhs  ^  alu_rhs;
                case Funct.OP_OR   alu_result = alu_lhs  |  alu_rhs;
                case Funct.OP_AND  alu_result = alu_lhs  &  alu_rhs;
            }
        }

        if opcode == Opcode.BRANCH switch instruction.funct3 {
            case Funct.BRANCH_BEQ  alu_result = { 31'b0, alu_lhs == alu_rhs };
            case Funct.BRANCH_BNE  alu_result = { 31'b0, alu_lhs != alu_rhs };
            case Funct.BRANCH_BLT  alu_result = { 31'b0, alu_lhs <  alu_rhs }; // Todo: sign
            case Funct.BRANCH_BGE  alu_result = { 31'b0, alu_lhs >= alu_rhs }; // Todo: sign
            case Funct.BRANCH_BLTU alu_result = { 31'b0, alu_lhs <  alu_rhs };
            case Funct.BRANCH_BGEU alu_result = { 31'b0, alu_lhs >= alu_rhs };
        }
    }
}

Controller :: module (clock: wire) {
    processor: Processor;

    data_memory: Memory;
    instruction_memory: Memory;

    combinational {
        processor.clock = clock;
    }
}

Memory :: module (clock: wire, wr_en: wire[4], store: wire[Word], address: wire[32]) -> (load: flipflop[32]) {
    Word :: register {
        byte_0[8];
        byte_1[8];
        byte_2[8];
        byte_3[8];
    }

    mem: ['h400] memory[Word];

    sequential (clock) {
        if wr_en[0] mem[address].byte_0 <= store.byte_0;
        if wr_en[1] mem[address].byte_1 <= store.byte_1;
        if wr_en[2] mem[address].byte_2 <= store.byte_2;
        if wr_en[3] mem[address].byte_3 <= store.byte_3;

        load <= mem[address];
    }
}

Opcode :: enum[7] {
    AUIPC  :: 'b00_101_11;
    LUI    :: 'b01_101_11;
    LOAD   :: 'b00_000_11;
    STORE  :: 'b01_000_11;
    OP_IMM :: 'b00_100_11;
    OP     :: 'b01_100_11;
    BRANCH :: 'b11_000_11;
    JALR   :: 'b11_001_11;
    JAL    :: 'b11_011_11;
}

Funct :: enum[3] {
    OP_ADD_SUB  :: 'b000;
    OP_SLL      :: 'b001;
    OP_SLT      :: 'b010;
    OP_SLTU     :: 'b011;
    OP_XOR      :: 'b100;
    OP_SRL_SRA  :: 'b101;
    OP_OR       :: 'b110;
    OP_AND      :: 'b111;

    BRANCH_BEQ  :: 'b000;
    BRANCH_BNE  :: 'b001;
    BRANCH_BLT  :: 'b010;
    BRANCH_BGE  :: 'b011;
    BRANCH_BLTU :: 'b100;
    BRANCH_BGEU :: 'b101;

    LOAD_LB     :: 'b000;
    LOAD_LH     :: 'b001;
    LOAD_LW     :: 'b010;
    LOAD_LBU    :: 'b100;
    LOAD_LHU    :: 'b101;

    STORE_SB    :: 'b000;
    STORE_SH    :: 'b001;
    STORE_SW    :: 'b010;
}
