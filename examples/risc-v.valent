
RiscV_Instruction :: bit_struct[32] {
    opcode    [Opcode];
    dest      [5];
    funct3    [Funct];
    source_a  [5];
    source_b  [5];
    funct7    [7];
}

// PR = Pipeline Register
PR_Fetch_Decode :: bit_struct {
    stalled;
    fetched [RiscV_Instruction];
}

PR_Decode_Execute :: bit_struct {
    stalled;
    instruction [RiscV_Instruction];

    immediate [64];
    source_a  [64];
    source_b  [64];
}

PR_Execute_Memory :: bit_struct {
    instruction [RiscV_Instruction];
    alu_result  [64];
    source_b    [64];
}

PR_Memory_Writeback :: bit_struct {
    instruction [RiscV_Instruction];
    alu_result  [64];
    source_b    [64];
}

Processor :: module (
    clock: wire,
    instruction: wire[64],
    data: wire[64]
) -> (
    pc: flipflop[64],
    write_enable: wire[8],
    data_out: wire[64],
    address: wire[64],
) {

    register_file: [32] memory[64];

    sequential (clock) {
        pc <- pc + 4;
        PR_fetch_decode.fetched <- instruction;
    }

    // ===============
    PR_fetch_decode: flipflop[PR_Fetch_Decode];
    // ===============

    imdec: Immediate_Decoder(PR_fetch_decode.fetched);

    sequential (clock) {
        PR_decode_execute.immediate <- imdec.output;

        PR_decode_execute.source_a  <- register_file[PR_fetch_decode.fetched.source_a];
        PR_decode_execute.source_b  <- register_file[PR_fetch_decode.fetched.source_b];
    }

    // ===============
    PR_decode_execute: flipflop[PR_Decode_Execute];
    // ===============

    alu: Arithmetic_Logic_Unit;

    combinational {
        inst := PR_decode_execute.instruction;

        use_immediate =
               inst.opcode == Opcode.OP_IMM
            || inst.opcode == Opcode.OP_IMM_32
            || inst.opcode == Opcode.LOAD
            || inst.opcode == Opcode.STORE
            || inst.opcode == Opcode.JALR;

        alu.op = {
            inst.opcode,
            inst.funct3,
            inst.funct7 != 0 && !use_immediate,
        };

        alu.lhs = PR_decode_execute.source_a;

        if use_immediate {
            alu.rhs = PR_decode_execute.immediate;
        } else {
            alu.rhs = PR_decode_execute.source_b;
        }
    }

    sequential (clock) {
        PR_execute_memory <- {
            alu.result,
            PR_decode_execute.instruction,
            PR_decode_execute.source_b,
        };
    }

    // ===============
    PR_execute_memory: flipflop[PR_Execute_Memory];
    // ===============

    byte_offset: wire[3];
    offset:      wire[6];

    combinational {
        write_enable = 8'b0;

        byte_offset = PR_execute_memory.alu_result[2:0];
        offset      = byte_offset * 8;

        if PR_execute_memory.instruction.opcode == Opcode.STORE {
            switch PR_execute_memory.instruction.funct3 {
                case Funct.STORE_SB write_enable = 8'b01 << byte_offset;
                case Funct.STORE_SH write_enable = 8'b11 << byte_offset;
                case Funct.STORE_SW write_enable = 8'h0f << byte_offset;
                else                write_enable = 8'hff;
            }
        }

        address  = { PR_execute_memory.alu_result[63:3], 3'b0 };
        data_out = PR_execute_memory.source_b << offset;
    }

    sequential (clock) {
        PR_memory_writeback <- PR_execute_memory;
    }

    // ===============
    PR_memory_writeback: flipflop[PR_Memory_Writeback];
    // ===============
}



Immediate_Decoder :: module (inst: wire[RiscV_Instruction]) -> output: wire[64] {

    combinational {

        I_immediate := { 53 # inst[31], inst[30:20] };
        S_immediate := { 53 # inst[31], inst[30:25], inst[11:7] };
        B_immediate := { 52 # inst[31], inst[7], inst[30:25], inst[11:8], 1'b0 };
        U_immediate := { 33 # inst[31], inst[30:12], 12'b0 };
        J_immediate := { 44 # inst[31], inst[19:12], inst[20], inst[30:25], inst[24:21], 1'b0 };

        switch instruction.opcode {
            case Opcode.AUIPC     output = U_immediate;
            case Opcode.LUI       output = U_immediate;
            case Opcode.LOAD      output = I_immediate;
            case Opcode.STORE     output = S_immediate;
            case Opcode.OP_IMM    output = I_immediate;
            case Opcode.OP_IMM_32 output = I_immediate;
            case Opcode.OP        output = 64'b0;
            case Opcode.OP_32     output = 64'b0;
            case Opcode.BRANCH    output = B_immediate;
            case Opcode.JAL       output = J_immediate;
            case Opcode.JALR      output = J_immediate;
            else                  output = 0;
        }
    }
}

Arithmetic_Logic_Unit :: module (op: wire[Operation], lhs: wire[64], rhs: wire[64]) -> result: wire[64] {

    Operation :: bit_struct {
        opcode [Opcode];
        funct3 [3]
        funct7;
    }

    is_op:     wire;
    is_branch: wire;

    combinational {
        is_op = op.opcode == Opcode.OP
             || op.opcode == Opcode.OP_IMM
             || op.opcode == Opcode.OP_32
             || op.opcode == Opcode.OP_IMM_32;

        is_branch = op.opcode == Opcode.BRANCH;

        // funct7 = op.funct7 > 0 && !use_immediate;

        if is_op switch op.funct3 {
            case Funct.OP_ADD_SUB
                if op.funct7   result       = lhs -  rhs;
                else           result =,trunc lhs +  rhs;
            case Funct.OP_SRL_SRA
                if op.funct7   result       = lhs >>> rhs;
                else           result       = lhs >> rhs;
            case Funct.OP_SLL  result       = lhs << rhs;
            case Funct.OP_SLT  result[0]    = lhs <  rhs; // Todo: sign
            case Funct.OP_SLTU result[0]    = lhs <  rhs;
            case Funct.OP_XOR  result       = lhs ^  rhs;
            case Funct.OP_OR   result       = lhs |  rhs;
            case Funct.OP_AND  result       = lhs &  rhs;
            else               result =,trunc lhs +  rhs;
        }

        else if is_branch switch op.funct3 {
            case Funct.BRANCH_BEQ  result = { 63'b0, lhs == rhs };
            case Funct.BRANCH_BNE  result = { 63'b0, lhs != rhs };
            case Funct.BRANCH_BLT  result = { 63'b0, lhs <  rhs }; // Todo: sign
            case Funct.BRANCH_BGE  result = { 63'b0, lhs >= rhs }; // Todo: sign
            case Funct.BRANCH_BLTU result = { 63'b0, lhs <  rhs };
            case Funct.BRANCH_BGEU result = { 63'b0, lhs >= rhs };
            else                   result = 0;
        }

        else result =,trunc lhs + rhs;
    }
}
