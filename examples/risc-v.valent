
RiscV_Instruction :: register[32] {
    opcode    [Opcode];
    dest      [5];
    funct3    [Funct];
    source_a  [5];
    source_b  [5];
    funct7    [7];
}

// PR = Pipeline Register
PR_Fetch_Decode :: register {
    stalled;
    fetched [RiscV_Instruction];
}

PR_Decode_Execute :: register {
    stalled;
    instruction [RiscV_Instruction];

    immediate [64];
    source_a  [64];
    source_b  [64];
}

Processor :: module (clock: wire, instruction: wire[64], data: wire[64]) -> pc: flipflop[64] {

    register_file: [32] memory[64];

    sequential (clock) {
        pc <- pc + 4;
        PR_fetch_decode.fetched <- instruction;
    }

    // ===============
    PR_fetch_decode: flipflop[PR_Fetch_Decode];
    // ===============

    imdec: Immediate_Decoder(PR_fetch_decode.fetched);

    sequential (clock) {
        PR_decode_execute.immediate <- imdec.output;

        PR_decode_execute.source_a  <- register_file[PR_fetch_decode.fetched.source_a];
        PR_decode_execute.source_b  <- register_file[PR_fetch_decode.fetched.source_b];
    }

    // ===============
    PR_decode_execute: flipflop[PR_Decode_Execute];
    // ===============

    alu: Arithmetic_Logic_Unit;
    prde_inst: wire[RiscV_Instruction];

    combinational {
        prde_inst = PR_decode_execute.instruction;

        use_immediate =
               prde_inst.opcode == Opcode.OP_IMM
            || prde_inst.opcode == Opcode.OP_IMM_32
            || prde_inst.opcode == Opcode.LOAD
            || prde_inst.opcode == Opcode.STORE
            || prde_inst.opcode == Opcode.JALR;

        alu.op = {
            prde_inst.opcode,
            prde_inst.funct3,
            prde_inst.funct7 != 0 && !use_immediate,
        };

        alu.lhs = PR_decode_execute.source_a;

        if use_immediate {
            alu.rhs = PR_decode_execute.immediate;
        } else {
            alu.rhs = PR_decode_execute.source_b;
        }
    }

    sequential (clock) {
        PR_execute_memory <- alu.result;
    }

    // ===============
    PR_execute_memory: flipflop[64];
    // ===============

    // ===============
    PR_memory_writeback: flipflop[RiscV_Instruction];
    // ===============
}



Immediate_Decoder :: module (instruction: wire[RiscV_Instruction]) -> output: wire[64] {

    I_immediate: wire[64];
    S_immediate: wire[64];
    B_immediate: wire[64];
    U_immediate: wire[64];
    J_immediate: wire[64];

    op: wire[32];

    combinational {
        op = instruction;

        I_immediate = { 53 # op[31], op[30:20] };
        S_immediate = { 53 # op[31], op[30:25], op[11:7] };
        B_immediate = { 52 # op[31], op[7], op[30:25], op[11:8], 1'b0 };
        U_immediate = { 33 # op[31], op[30:12], 12'b0 };
        J_immediate = { 44 # op[31], op[19:12], op[20], op[30:25], op[24:21], 1'b0 };

        switch instruction.opcode {
            case Opcode.AUIPC     output = U_immediate;
            case Opcode.LUI       output = U_immediate;
            case Opcode.LOAD      output = I_immediate;
            case Opcode.STORE     output = S_immediate;
            case Opcode.OP_IMM    output = I_immediate;
            case Opcode.OP_IMM_32 output = I_immediate;
            case Opcode.OP        output = 64'b0;
            case Opcode.OP_32     output = 64'b0;
            case Opcode.BRANCH    output = B_immediate;
            case Opcode.JAL       output = J_immediate;
            case Opcode.JALR      output = J_immediate;
            else                  output = 0;
        }
    }
}

Arithmetic_Logic_Unit :: module (op: wire[Operation], lhs: wire[64], rhs: wire[64]) -> result: wire[64] {

    Operation :: register {
        opcode [Opcode];
        funct3 [3]
        funct7;
    }

    is_op:     wire;
    is_branch  wire;

    combinational {
        is_op = op.opcode == Opcode.OP
             || op.opcode == Opcode.OP_IMM
             || op.opcode == Opcode.OP_32
             || op.opcode == Opcode.OP_IMM_32;

        is_branch = op.opcode == Opcode.BRANCH;

        // funct7 = op.funct7 > 0 && !use_immediate;

        if is_op switch op.funct3 {
            case Funct.OP_ADD_SUB
                if op.funct7   result       = lhs -  rhs;
                else           result =,trunc lhs +  rhs;
            case Funct.OP_SRL_SRA
                if op.funct7   result       = lhs >>> rhs;
                else           result       = lhs >> rhs;
            case Funct.OP_SLL  result       = lhs << rhs;
            case Funct.OP_SLT  result[0]    = lhs <  rhs; // Todo: sign
            case Funct.OP_SLTU result[0]    = lhs <  rhs;
            case Funct.OP_XOR  result       = lhs ^  rhs;
            case Funct.OP_OR   result       = lhs |  rhs;
            case Funct.OP_AND  result       = lhs &  rhs;
            else               result =,trunc lhs +  rhs;
        }

        else if is_branch switch op.funct3 {
            case Funct.BRANCH_BEQ  result = { 63'b0, lhs == rhs };
            case Funct.BRANCH_BNE  result = { 63'b0, lhs != rhs };
            case Funct.BRANCH_BLT  result = { 63'b0, lhs <  rhs }; // Todo: sign
            case Funct.BRANCH_BGE  result = { 63'b0, lhs >= rhs }; // Todo: sign
            case Funct.BRANCH_BLTU result = { 63'b0, lhs <  rhs };
            case Funct.BRANCH_BGEU result = { 63'b0, lhs >= rhs };
            else                   result = 0;
        }

        else result =,trunc lhs + rhs;
    }
}
